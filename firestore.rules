rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Users can read their own profile; public fields can be split if needed
    match /users/{userId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow write: if request.auth != null && request.auth.uid == userId;
    }

    // Conversations: only members can read/write
    match /conversations/{convId} {
      allow read, update, delete: if request.auth != null && request.auth.uid in resource.data.members;
      allow create: if request.auth != null && request.resource.data.members is list
                    && request.auth.uid in request.resource.data.members
                    && request.resource.data.membersKey is string;

      // Messages subcollection: only members can read/write
      match /messages/{msgId} {
        allow read, create: if request.auth != null && request.auth.uid in get(/databases/$(database)/documents/conversations/$(convId)).data.members;
        allow update, delete: if false; // Prevent edits/deletes by clients; treat messages as immutable
      }
    }

    // Videos: public read, authed create; authed updates restricted to ratings/viewers; owner can delete
    match /videos/{videoId} {
      allow read: if true;
      allow create: if request.auth != null
                    && request.resource.data.url is string
                    && request.resource.data.userId == request.auth.uid;
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
      allow update: if request.auth != null
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(["ratings", "viewers", "updatedAt"]) 
        && (
          // If ratings provided, only the caller's key may change and value must be 1..5
          !("ratings" in request.resource.data) || (
            request.resource.data.ratings.diff(resource.data.ratings).changedKeys().hasOnly([request.auth.uid]) &&
            request.resource.data.ratings[request.auth.uid] is int &&
            request.resource.data.ratings[request.auth.uid] >= 1 && request.resource.data.ratings[request.auth.uid] <= 5
          )
        ) && (
          // If viewers provided, only the caller's key may be added/changed and must be true; no removals
          !("viewers" in request.resource.data) || (
            request.resource.data.viewers.diff(resource.data.viewers).removedKeys().size() == 0 &&
            request.resource.data.viewers.diff(resource.data.viewers).changedKeys().hasOnly([request.auth.uid]) &&
            request.resource.data.viewers[request.auth.uid] == true
          )
        );
    }

    // Personal Journey: users can read all journeys (optional), but can only create/delete their own
    match /journeys/{journeyId} {
      allow read: if true; // make public to showcase journeys; optionally restrict by auth
      allow create: if request.auth != null
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.title is string
                    && request.resource.data.date is string;
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
      allow update: if false; // immutable from client; delete+recreate if needed
    }

    // Questions: public read, authed create; owner can delete; limited updates for answers/votes/views
    match /questions/{questionId} {
      allow read: if true;
      allow create: if request.auth != null
                    && request.resource.data.title is string
                    && request.resource.data.userId == request.auth.uid;
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
      allow update: if request.auth != null
                    && request.resource.data.diff(resource.data).changedKeys().hasOnly(["answers", "votes", "views", "updatedAt"]);
    }
  }
}
